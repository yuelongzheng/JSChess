const PIECES = { EMPTY : 0, wP : 1, wN : 2, wB : 3, wR : 4, wQ : 5, wK : 6,
                bP : 7, bN : 8, bB : 9, bR : 10, bQ : 11, bK: 12};

const BOARD_SQUARE_NUM = 120;
const ACTIVE_SQUARE_NUM = 64;

const FILES = {FILE_A : 0 , FILE_B : 1, FILE_C : 2, FILE_D : 3, 
            FILE_E : 4, FILE_F : 5, FILE_G : 6, FILE_H : 7, FILE_NONE : 8};
const RANKS = {RANK_1 : 0, RANK_2 : 1, RANK_3 : 2, RANK_4 : 3,
            RANK_5 : 4, RANK_6 : 5, RANK_7 : 6, RANK_8 : 7, RANK_NONE : 8};

const COLOURS = { WHITE : 0, BLACK : 1, BOTH : 2};

const CASTLE_BIT = { WHITE_KING_SIDE_CASTLE : 1, WHITE_QUEEN_SIDE_CASTLE : 2, 
        BLACK_KING_SIDE_CASTLE : 4, BLACK_QUEEN_SIDE_CASTLE : 8};

const SQUARES = {
        A1 : 21, B1 : 22, C1 : 23, D1 : 24, E1 : 25, F1 : 26, G1 : 27, H1: 28,
        A8 : 91, B8 : 92, C8 : 93, D8 : 94, E8 : 95, F8 : 96, G8 : 97, H8: 98,
        NO_SQUARE : 99, OFFBOARD : 100
    };

const BOOL = {FALSE : 0, TRUE : 1};

const MAX_GAME_MOVES = 2048;
const MAX_POSITION_MOVES = 256;
const MAX_DEPTH = 64;
const INFINITE = 30000;
const MATE = 29000;
const PV_ENTRIES = 10000;

const FilesBoard = new Array(BOARD_SQUARE_NUM);
const RanksBoard = new Array(BOARD_SQUARE_NUM);
InitFilesRanksBoard();

const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

const PieceChar = ".PNBRQKpnbrqk"
const SideChar = "wb-";
const RankChar = "12345678";
const FileChar = "abcdefgh";

// Determines whether a piece is a big/major/minor piece
const PieceBig = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE ];
const PieceMaj = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE ];
const PieceMin = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];
const PieceVal= [ 0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, 1000, 50000  ];
const PieceCol = [ COLOURS.BOTH, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE,
	COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK ];

// For the PIECES array return whether given index/piece is a pawn/knight/.../etc
const PiecePawn = [ BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];	
const PieceKnight = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];
const PieceKing = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE ];
const PieceRookQueen = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE ];
const PieceBishopQueen = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE ];
// Rooks, bishops, queens are sliding pieces
const PieceSlides = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE ];

const KnightDirections = [ -8, -19, -21, -12, 8, 19, 21, 12];
const RookDirections = [-1, -10, 1, 10];
const BishopDirections = [-9, -11, 11, 9];
const KingDirections = [-1, -10, 1, 10, -9, -11, 11, 9];

const PieceToDirectionsLength = [0, 0, 8, 4, 4, 8, 8, 0, 8, 4, 4, 8, 8];
const PieceToDirections = [0, 0, KnightDirections, BishopDirections, RookDirections, KingDirections, KingDirections,
                            0, KnightDirections, BishopDirections, RookDirections, KingDirections, KingDirections];
const NonSlidingPieces = [PIECES.wN, PIECES.wK, 0, PIECES.bN, PIECES.bK, 0];
const NonSlidingStartingIndex = [0, 3];
const SlidingPieces = [PIECES.wB, PIECES.wR, PIECES.wQ, 0, PIECES.bB, PIECES.bR, PIECES.bQ, 0];
const SlidingPiecesStartingIndex = [0, 4];

/*
    120 squares and 13 possible pieces
    Allow for a unique index for each piece and each square
    Hash generated by 120 * Piece + square
*/
const PieceKeys = new Array(13 * 120);
let SideKey;
// Castling requires 4 bits, which has a max value of 15
const CastleKeys = new Array(16);
InitHashKeys();

// There are 64 on board squares, 120 array to 0 to 63
const Square120ToSquare64 = new Array(BOARD_SQUARE_NUM);
const Square64ToSquare120 = new Array(64);

InitSquare120ToSquare64();

const Kings = [PIECES.wK, PIECES.bK];
/*
    Array filled with 15s, except in indices corresponding to
    A1, E1, H1, A8, E8, H8. (Rook and king locations)
    Used to alter GameBoard.castlePermission
*/
const Castle_Permission_Array = [
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 13, 15, 15, 15, 12, 15, 15, 14, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15,  7, 15, 15, 15,  3, 15, 15, 11, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15
];

// Generates a random 31 bit number
// Tried to do 32, however that results in integer overflow
function RAND_31(){
    return (Math.floor((Math.random()*255) + 1) << 23 | Math.floor((Math.random()*255) + 1) << 16 | 
            Math.floor((Math.random()*255) + 1) << 8 | Math.floor((Math.random()*255) + 1));
}

const mirror64 = [
56	,	57	,	58	,	59	,	60	,	61	,	62	,	63	,
48	,	49	,	50	,	51	,	52	,	53	,	54	,	55	,
40	,	41	,	42	,	43	,	44	,	45	,	46	,	47	,
32	,	33	,	34	,	35	,	36	,	37	,	38	,	39	,
24	,	25	,	26	,	27	,	28	,	29	,	30	,	31	,
16	,	17	,	18	,	19	,	20	,	21	,	22	,	23	,
8	,	9	,	10	,	11	,	12	,	13	,	14	,	15	,
0	,	1	,	2	,	3	,	4	,	5	,	6	,	7   ];

/*
    In - Integer 0 - 119
    Out - Integer 0 - 64
        0 - 63 : Actual board squares
        64 : Not a board square
*/
function square64(square120){
    return Square120ToSquare64[(square120)];
}

/*
    In - Integer 0 - 63
    Out - Integer 0 - 120
        0 - 119 : Actual board squares
        120 : Not a board square
*/
function square120(square64){
    return Square64ToSquare120[(square64)];
}

/*
    Used for pieceList
*/
function pieceIndex(piece, pieceNumber){
    return (piece * 10 + pieceNumber);
}

function mirror64Index(square){
    return mirror64[square];
}

function InitFilesRanksBoard(){
        FilesBoard.fill(SQUARES.OFFBOARD, 0, FilesBoard.length);
        RanksBoard.fill(SQUARES.OFFBOARD, 0, RanksBoard.length);
        let square;
        for(let rank = RANKS.RANK_1 ; rank <= RANKS.RANK_8 ; rank++){
            for(let file = FILES.FILE_A ; file <= FILES.FILE_H ; file++){
                square = FileRankToSquare(file, rank);
                FilesBoard[square] = file;
                RanksBoard[square] = rank;
            }
        }
};

function InitHashKeys(){
    // PieceKeys.fill(RAND_31(), 0, PieceKeys.length)
    // This is unacceptable becuase RAND_31 is called once only, instead of multiple times
    for(let index = 0 ; index < PieceKeys.length ; index++){
        PieceKeys[index] = RAND_31();
    }
    SideKey = RAND_31();
    for(let index = 0 ; index < CastleKeys.length ; index++){
        CastleKeys[index] = RAND_31();
    }
}


function InitSquare120ToSquare64(){
    let square64 = 0;
    let outOfIndex64 = 64;
    let square;
    Square120ToSquare64.fill(outOfIndex64, 0, Square120ToSquare64.length);
    Square64ToSquare120.fill(BOARD_SQUARE_NUM, 0, Square64ToSquare120.length);
    for(let rank = RANKS.RANK_1 ; rank <= RANKS.RANK_8 ; rank++){
        for(let file = FILES.FILE_A ; file <= FILES.FILE_H ; file++){
            square = FileRankToSquare(file, rank);
            Square64ToSquare120[square64] = square;
            Square120ToSquare64[square] = square64++;
        }
    }
}
/*
    Given a file and rank
    return the corresponding index in the board array (length 120)
*/
function FileRankToSquare(file ,rank) { 
        const starting_square = 21;
        const row_length = 10; // In the 120 array the row length is 10
        return ((starting_square + file) + (row_length * rank));
};

/*
    Move information can be packed into 25 bits
    0 0000 0000 0000 0000 0000 0000

    Since the active square indices range from 21 to 98 7 bits are required, 
    which in hexadecimal comes out as 0x7F.

    The from square are stored by the 7 most right bits
    0 0000 0000 0000 0000 0111 1111
    The to square are stored by are stored in the 7 next bits
    0 0000 0000 0011 1111 1000 0000

    There are 12 total pieces that can be captured, this can be stored in the next 4 bits
    0 0000 0011 1100 0000 0000 0000 (14 zeroes behind the ones)

    The next bit stores whether a move is an en passant move
    0 0000 0100 0000 0000 0000 0000 - in hex this is 0x40000

    The next bit stores whether a move is a pawn starting move
    0 0000 1000 0000 0000 0000 0000 - in hex this is 0x80000

    The next bit stores pawn promotion details, requires 4 bits
    0 1111 0000 0000 0000 0000 0000 - in hex this is 0xF00000 (20 zeroes behind the ones)

    The next bit stores whether or not the move was a castling move
    1 0000 0000 0000 0000 0000 0000 - in hex this is 0x1000000
 
*/
function getFromSquare(move){
    return (move & 0x7F);
}
function getToSquare(move){
    return ((move >> 7) & 0x7F);
}
function getCapturedPiece(move){
    return ((move >> 14) & 0xF);
}
function getPromotion(move){
    return ((move >> 20) & 0xF);
}

let MOVE_FLAG_EN_PASSANT = 0x40000;
let MOVE_FLAG_PAWN_START = 0x80000;
let MOVE_FLAG_CASTLE = 0x1000000;

let MOVE_FLAG_CAPTURE = 0x7C000; // includes the en passant bit and move capture bits
let MOVE_FLAG_PROMOTION = 0xF00000;

let NO_MOVE = 0;

let ONE_RANK_MOVE = 10;

module.exports = {
    PIECES, BOARD_SQUARE_NUM, ACTIVE_SQUARE_NUM, FILES, RANKS, COLOURS, CASTLE_BIT,
    SQUARES, BOOL, MAX_GAME_MOVES, MAX_POSITION_MOVES, MAX_DEPTH, INFINITE, MATE,
    FilesBoard, RanksBoard, START_FEN, PieceChar, SideChar, RankChar, FileChar,
    PieceBig, PieceMaj, PieceMin, PieceVal, PieceCol, PiecePawn, PieceKnight,
    PieceKing, PieceRookQueen, PieceBishopQueen, PieceSlides, KnightDirections,
    RookDirections, BishopDirections, KingDirections, PieceToDirectionsLength,
    PieceToDirections, NonSlidingPieces, NonSlidingStartingIndex, SlidingPieces,
    SlidingPiecesStartingIndex, PieceKeys, SideKey, CastleKeys, Square120ToSquare64,
    Square64ToSquare120, Kings, Castle_Permission_Array, MOVE_FLAG_EN_PASSANT,
    MOVE_FLAG_PAWN_START, MOVE_FLAG_CASTLE, MOVE_FLAG_CAPTURE, MOVE_FLAG_PROMOTION,
    NO_MOVE, ONE_RANK_MOVE, mirror64, PV_ENTRIES,
    RAND_31, square64, square120, pieceIndex, InitFilesRanksBoard, FileRankToSquare,
    getFromSquare, getToSquare, getCapturedPiece, getPromotion, InitHashKeys, InitSquare120ToSquare64,
    mirror64Index,
}