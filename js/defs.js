let PIECES = { EMPTY : 0, wP : 1, wN : 2, wB : 3, wR : 4, wQ : 5, wK : 6,
                bP : 7, bN : 8, bB : 9, bR : 10, bQ : 11, bK: 12};

let BOARD_SQUARE_NUM = 120;
let ACTIVE_SQUARE_NUM = 64; 

let FILES = {FILE_A : 0 , FILE_B : 1, FILE_C : 2, FILE_D : 3, 
    FILE_E : 4, FILE_F : 5, FILE_G : 6, FILE_H : 7, FILE_NONE : 8};

let RANKS = {RANK_1 : 0, RANK_2 : 1, RANK_3 : 2, RANK_4 : 3,
     RANK_5 : 4, RANK_6 : 5, RANK_7 : 6, RANK_8 : 7, RANK_NONE : 8};

let COLOURS = { WHITE : 0, BLACK : 1, BOTH : 2};

let CASTLE_BIT = { WHITE_KING_SIDE_CASTLE : 1, WHITE_QUEEN_SIDE_CASTLE : 2, 
    BLACK_KING_SIDECASTLE : 3, BLACK_QUEEN_SIDE_CASTLE : 4}

let SQUARES = {
    A1 : 21, B1 : 22, C1 : 23, D1 : 24, E1 : 25, F1 : 26, G1 : 27, H1: 28,
    A8 : 91, B8 : 92, C8 : 93, D8 : 94, E8 : 95, F8 : 96, G8 : 97, H8: 98,
    NO_SQUARE : 99, OFFBOARD : 100
};

let BOOL = {FALSE : 0, TRUE : 1};

// Maximum number of moves in a game
// this is well the max number of moves in a recorded game of chess
let MAXGAMEMOVES = 2048;
// Maximum number of moves that can be generated in a given position
let MAXPOSITIONMOVES = 256;
// Search depth for AI
let MAXDEPTH = 64; 

let FilesBoard = new Array(BOARD_SQUARE_NUM);
let RanksBoard = new Array(BOARD_SQUARE_NUM);

let START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

let PieceChar = ".PNBRQKpnbrqk"
let SideChar = "wb-";
let RankChar = "12345678";
let FileChar = "abcdefgh";

function FileRankToSquare(file ,rank) { 
    let starting_square = 21;
    let row_length = 10; // In the 120 array the row length is 10
    return ((starting_square + file) + (row_length * rank));
}

// Determines whether a piece is a big/major/minor piece
let PieceBig = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE ];
let PieceMaj = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE ];
let PieceMin = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];
let PieceVal= [ 0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, 1000, 50000  ];
let PieceCol = [ COLOURS.BOTH, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE,
	COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK ];
	
let PiecePawn = [ BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];	
let PieceKnight = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];
let PieceKing = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE ];
let PieceRookQueen = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE ];
let PieceBishopQueen = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE ];
// Rooks, bishops, queens are sliding pieces
let PieceSlides = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE ];

/*
    120 squares and 14(13 really, more space???) possible pieces
    Allow for a unique index for each piece and each square
    Hash generated by 120 * Piece + square
*/
let PieceKeys = new Array(14 * 120);
let SideKey;
// Castling requires 4 bits, which has a max value of 15
let CastleKeys = new Array(16);

// There are 64 on board squares, 120 array to 0 to 63
let Square120ToSquare64 = new Array(BOARD_SQUARE_NUM);
let Square64ToSquare120 = new Array(64);


// Generates a random 31 bit number
// Tried to do 32, however that results in integer overflow
function RAND_31(){
    return (Math.floor((Math.random()*255) + 1) << 23 | Math.floor((Math.random()*255) + 1) << 16 | 
            Math.floor((Math.random()*255) + 1) << 8 | Math.floor((Math.random()*255) + 1));
}

/*
    In - Integer 0 - 119
    Out - Integer 0 - 64
        0 - 63 : Actual board squares
        64 : Not a board square
*/
function square64(square120){
    return Square120ToSquare64[(square120)];
}

/*
    In - Integer 0 - 63
    Out - Integer 0 - 120
        0 - 119 : Actual board squares
        120 : Not a board square
*/
function square120(square64){
    return Square64ToSquare120[(square64)];
}

/*
    Used for pieceList
*/
function pieceIndex(piece, pieceNumber){
    return (piece * 10 + pieceNumber);
}