let PIECES = { EMPTY : 0, wP : 1, wN : 2, wB : 3, wR : 4, wQ : 5, wK : 6,
                bP : 7, bN : 8, bB : 9, bR : 10, bQ : 11, bK: 12};

let BOARD_SQUARE_NUM = 120;
let ACTIVE_SQUARE_NUM = 64; 

let FILES = {FILE_A : 0 , FILE_B : 1, FILE_C : 2, FILE_D : 3, 
    FILE_E : 4, FILE_F : 5, FILE_G : 6, FILE_H : 7, FILE_NONE : 8};

let RANKS = {RANK_1 : 0, RANK_2 : 1, RANK_3 : 2, RANK_4 : 3,
     RANK_5 : 4, RANK_6 : 5, RANK_7 : 6, RANK_8 : 7, RANK_NONE : 8};

let COLOURS = { WHITE : 0, BLACK : 1, BOTH : 2};

let CASTLE_BIT = { WHITE_KING_SIDE_CASTLE : 1, WHITE_QUEEN_SIDE_CASTLE : 2, 
    BLACK_KING_SIDECASTLE : 3, BLACK_QUEEN_SIDE_CASTLE : 4}

let SQUARES = {
    A1 : 21, B1 : 22, C1 : 23, D1 : 24, E1 : 25, F1 : 26, G1 : 27, H1: 28,
    A8 : 91, B8 : 92, C8 : 93, D8 : 94, E8 : 95, F8 : 96, G8 : 97, H8: 98,
    NO_SQUARE : 99, OFFBOARD : 100
};

let BOOL = {FALSE : 0, TRUE : 1};

let MAX_GAME_MOVES = 2048;
let MAX_POSITION_MOVES = 256;
let MAX_DEPTH = 64; 

// For a given index return the file
let FilesBoard = new Array(BOARD_SQUARE_NUM);
// For a given index return the rank
let RanksBoard = new Array(BOARD_SQUARE_NUM);

let START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

let PieceChar = ".PNBRQKpnbrqk"
let SideChar = "wb-";
let RankChar = "12345678";
let FileChar = "abcdefgh";

/*
    Given a file and rank
    return the corresponding index in the board array (length 120)
*/
function FileRankToSquare(file ,rank) { 
    let starting_square = 21;
    let row_length = 10; // In the 120 array the row length is 10
    return ((starting_square + file) + (row_length * rank));
}

// Determines whether a piece is a big/major/minor piece
let PieceBig = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE ];
let PieceMaj = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE ];
let PieceMin = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];
let PieceVal= [ 0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, 1000, 50000  ];
let PieceCol = [ COLOURS.BOTH, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE,
	COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK ];

// For the PIECES array return whether given index/piece is a pawn/knight/.../etc
let PiecePawn = [ BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];	
let PieceKnight = [ BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE ];
let PieceKing = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE ];
let PieceRookQueen = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE ];
let PieceBishopQueen = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE ];
// Rooks, bishops, queens are sliding pieces
let PieceSlides = [ BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE ];

let KnightDirections = [ -8, -19, -21, -12, 8, 19, 21, 12];
let RookDirections = [-1, -10, 1, 10];
let BishopDirections = [-9, -11, 11, 9];
let KingDirections = [-1, -10, 1, 10, -9, -11, 11, 9];

let PieceToDirectionsLength = [0, 0, 8, 4, 4, 8, 8, 0, 8, 4, 4, 8, 8];
let PieceToDirections = [0, 0, KnightDirections, BishopDirections, RookDirections, KingDirections, KingDirections,
                            0, KnightDirections, BishopDirections, RookDirections, KingDirections, KingDirections];
let NonSlidingPieces = [PIECES.wN, PIECES.wK, 0, PIECES.bN, PIECES.bK, 0];
let NonSlidingStartingIndex = [0, 3];
let SlidingPieces = [PIECES.wB, PIECES.wR, PIECES.wQ, 0, PIECES.bB, PIECES.bR, PIECES.bQ, 0];
let SlidingPiecesStartingIndex = [0, 4];

/*
    120 squares and 14(13 really, more space???) possible pieces
    Allow for a unique index for each piece and each square
    Hash generated by 120 * Piece + square
*/
let PieceKeys = new Array(14 * 120);
let SideKey;
// Castling requires 4 bits, which has a max value of 15
let CastleKeys = new Array(16);

// There are 64 on board squares, 120 array to 0 to 63
let Square120ToSquare64 = new Array(BOARD_SQUARE_NUM);
let Square64ToSquare120 = new Array(64);


// Generates a random 31 bit number
// Tried to do 32, however that results in integer overflow
function RAND_31(){
    return (Math.floor((Math.random()*255) + 1) << 23 | Math.floor((Math.random()*255) + 1) << 16 | 
            Math.floor((Math.random()*255) + 1) << 8 | Math.floor((Math.random()*255) + 1));
}

/*
    In - Integer 0 - 119
    Out - Integer 0 - 64
        0 - 63 : Actual board squares
        64 : Not a board square
*/
function square64(square120){
    return Square120ToSquare64[(square120)];
}

/*
    In - Integer 0 - 63
    Out - Integer 0 - 120
        0 - 119 : Actual board squares
        120 : Not a board square
*/
function square120(square64){
    return Square64ToSquare120[(square64)];
}

/*
    Used for pieceList
*/
function pieceIndex(piece, pieceNumber){
    return (piece * 10 + pieceNumber);
}

let Kings = [PIECES.wK, PIECES.bK];
/*
    Array filled with 15s, except in indices corresponding to
    A1, E1, H1, A8, E8, H8. (Rook and king locations)
    Used to alter GameBoard.castlePermission
*/
let Castle_Permission_Array = [
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 13, 15, 15, 15, 12, 15, 15, 14, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15,  7, 15, 15, 15,  3, 15, 15, 11, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15
];

/*
    Move information can be packed into 25 bits
    0 0000 0000 0000 0000 0000 0000

    Since the active square indices range from 21 to 98 7 bits are required, 
    which in hexadecimal comes out as 0x7F.

    The from square are stored by the 7 most right bits
    0 0000 0000 0000 0000 0111 1111
    The to square are stored by are stored in the 7 next bits
    0 0000 0000 0011 1111 1000 0000

    There are 12 total pieces that can be captured, this can be stored in the next 4 bits
    0 0000 0011 1100 0000 0000 0000 (14 zeroes behind the ones)

    The next bit stores whether a move is an en passant move
    0 0000 0100 0000 0000 0000 0000 - in hex this is 0x40000

    The next bit stores whether a move is a pawn starting move
    0 0000 1000 0000 0000 0000 0000 - in hex this is 0x80000

    The next bit stores pawn promotion details, requires 4 bits
    0 1111 0000 0000 0000 0000 0000 - in hex this is 0xF00000 (20 zeroes behind the ones)

    The next bit stores whether or not the move was a castling move
    1 0000 0000 0000 0000 0000 0000 - in hex this is 0x1000000
 
*/
function getFromSquare(move){
    return (move & 0x7F);
}
function getToSquare(move){
    return ((move >> 7) & 0x7F);
}
function getCapturedPiece(move){
    return ((move >> 14) & 0xF);
}
function getPromotion(move){
    return ((move >> 20) & 0xF);
}

let MOVE_FLAG_EN_PASSANT = 0x40000;
let MOVE_FLAG_PAWN_START = 0x80000;
let MOVE_FLAG_CASTLE = 0x1000000;

let MOVE_FLAG_CAPTURE = 0x7C000; // includes the en passant bit and move capture bits
let MOVE_FLAG_PROMOTION = 0xF00000;

let NO_MOVE = 0;

function IsSquareOffBoard(square){
    if(GameBoard.pieces[square] == SQUARES.OFFBOARD){
        return BOOL.TRUE;
    }
    return BOOL.FALSE;
}

let ONE_RANK_MOVE = 10;

function HashPiece(piece, square){
    GameBoard.posKey ^= PieceKeys[(piece * 120) + square];
}

function HashCastle(){
    GameBoard.posKey ^= CastleKeys[GameBoard.castlePermission];
}

function HashSide(){
    GameBoard.posKey ^= SideKey;
}

function HashEnPassant(){
    GameBoard.posKey ^= PieceKeys[GameBoard.enPassant];
}